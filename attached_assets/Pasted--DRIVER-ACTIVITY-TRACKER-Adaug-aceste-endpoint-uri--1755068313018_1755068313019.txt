// ==================== DRIVER ACTIVITY TRACKER ====================
// Adaug캒 aceste endpoint-uri 칥n registerRoutes function din server-ul t캒u

// Driver activity analysis endpoints
app.get("/api/driver-activity/monthly/:year/:month", async (req, res) => {
  try {
    const { year, month } = req.params;
    const activity = await analyzeDriverActivityForMonth(parseInt(year), parseInt(month));
    res.json(activity);
  } catch (error) {
    console.error("Error analyzing driver activity:", error);
    res.status(500).json({ error: "Failed to analyze driver activity" });
  }
});

app.get("/api/driver-activity/driver/:driverName/:year/:month", async (req, res) => {
  try {
    const { driverName, year, month } = req.params;
    const activity = await getDriverDetailedActivity(driverName, parseInt(year), parseInt(month));
    res.json(activity);
  } catch (error) {
    console.error("Error getting driver detailed activity:", error);
    res.status(500).json({ error: "Failed to get driver activity details" });
  }
});

app.get("/api/driver-activity/summary/:year", async (req, res) => {
  try {
    const { year } = req.params;
    const summary = await getYearlyDriverActivitySummary(parseInt(year));
    res.json(summary);
  } catch (error) {
    console.error("Error getting yearly activity summary:", error);
    res.status(500).json({ error: "Failed to get yearly activity summary" });
  }
});

// ==================== ANALYSIS FUNCTIONS ====================

/**
 * Analizeaz캒 activitatea 탳oferilor pentru o lun캒 specific캒
 */
async function analyzeDriverActivityForMonth(year, month) {
  console.log(`游늵 Analyzing driver activity for ${month}/${year}`);
  
  // Ob탵ine toate proces캒rile s캒pt캒m칙nale pentru luna specificat캒
  const weeklyData = await storage.getAllWeeklyProcessing();
  
  // Filtreaz캒 datele pentru luna 탳i anul specificate
  const monthlyWeeks = weeklyData.filter(week => {
    const weekDate = parseWeekLabel(week.weekLabel);
    return weekDate.year === year && weekDate.month === month;
  });

  const driverActivity = {};
  const allDrivers = new Set();

  // Proceseaz캒 fiecare s캒pt캒m칙n캒
  for (const week of monthlyWeeks) {
    if (!week.processedData) continue;

    const processedData = week.processedData;
    const weekInfo = parseWeekLabel(week.weekLabel);

    // Extrage informa탵ii despre 탳oferi din datele procesate
    Object.keys(processedData).forEach(companyName => {
      if (companyName === 'Unmatched' || companyName === 'Totals') return;

      const companyData = processedData[companyName];
      
      // Caut캒 탳oferii activi 칥n datele companiei
      if (companyData.drivers) {
        Object.keys(companyData.drivers).forEach(driverName => {
          const driverData = companyData.drivers[driverName];
          
          if (!driverActivity[driverName]) {
            driverActivity[driverName] = {
              name: driverName,
              company: companyName,
              activeWeeks: [],
              totalTrips: 0,
              totalRevenue: 0,
              workDays: 0,
              restDays: 0
            };
          }

          allDrivers.add(driverName);

          // Verific캒 dac캒 탳oferul a fost activ (cel pu탵in 2 curse)
          const tripCount = driverData.tripCount || 0;
          if (tripCount >= 2) {
            driverActivity[driverName].activeWeeks.push({
              week: week.weekLabel,
              weekNumber: weekInfo.weekNumber,
              tripCount: tripCount,
              revenue: parseFloat(driverData.totalRevenue || 0)
            });

            driverActivity[driverName].totalTrips += tripCount;
            driverActivity[driverName].totalRevenue += parseFloat(driverData.totalRevenue || 0);
          }
        });
      }
    });
  }

  // Calculeaz캒 zilele de munc캒 탳i odihn캒 pentru fiecare 탳ofer
  const daysInMonth = new Date(year, month, 0).getDate();
  const totalWorkingDays = getWorkingDaysInMonth(year, month);

  Object.keys(driverActivity).forEach(driverName => {
    const driver = driverActivity[driverName];
    
    // Estimeaz캒 zilele de munc캒 bazat pe s캒pt캒m칙nile active
    // Presupunem c캒 o s캒pt캒m칙n캒 activ캒 = 5-6 zile de munc캒
    const activeWeeksCount = driver.activeWeeks.length;
    const estimatedWorkDays = Math.min(activeWeeksCount * 5.5, totalWorkingDays);
    
    driver.workDays = Math.round(estimatedWorkDays);
    driver.restDays = daysInMonth - driver.workDays;
    driver.activityRate = (driver.workDays / totalWorkingDays * 100).toFixed(1);
  });

  return {
    year,
    month,
    monthName: getMonthName(month),
    totalDrivers: Object.keys(driverActivity).length,
    daysInMonth,
    totalWorkingDays,
    drivers: Object.values(driverActivity)
      .sort((a, b) => b.totalTrips - a.totalTrips), // Sorteaz캒 dup캒 num캒rul de curse
    summary: {
      mostActiveDriver: Object.values(driverActivity)
        .reduce((max, driver) => driver.totalTrips > max.totalTrips ? driver : max, { totalTrips: 0 }),
      averageTripsPerDriver: Object.values(driverActivity)
        .reduce((sum, driver) => sum + driver.totalTrips, 0) / Object.keys(driverActivity).length || 0,
      totalTripsAllDrivers: Object.values(driverActivity)
        .reduce((sum, driver) => sum + driver.totalTrips, 0)
    }
  };
}

/**
 * Ob탵ine activitatea detaliat캒 pentru un 탳ofer specific
 */
async function getDriverDetailedActivity(driverName, year, month) {
  console.log(`游댌 Getting detailed activity for ${driverName} in ${month}/${year}`);
  
  const weeklyData = await storage.getAllWeeklyProcessing();
  
  const monthlyWeeks = weeklyData.filter(week => {
    const weekDate = parseWeekLabel(week.weekLabel);
    return weekDate.year === year && weekDate.month === month;
  });

  const driverDetails = {
    name: driverName,
    year,
    month,
    monthName: getMonthName(month),
    weeklyActivity: [],
    summary: {
      totalActiveWeeks: 0,
      totalTrips: 0,
      totalRevenue: 0,
      averageTripsPerWeek: 0,
      bestWeek: null,
      worstWeek: null
    }
  };

  let bestWeek = { trips: 0, week: '' };
  let worstWeek = { trips: Infinity, week: '' };

  for (const week of monthlyWeeks) {
    if (!week.processedData) continue;

    const processedData = week.processedData;
    let driverFound = false;
    let weekActivity = {
      week: week.weekLabel,
      weekNumber: parseWeekLabel(week.weekLabel).weekNumber,
      isActive: false,
      tripCount: 0,
      revenue: 0,
      company: ''
    };

    // Caut캒 탳oferul 칥n datele procesate
    Object.keys(processedData).forEach(companyName => {
      if (companyName === 'Unmatched' || companyName === 'Totals') return;

      const companyData = processedData[companyName];
      
      if (companyData.drivers && companyData.drivers[driverName]) {
        const driverData = companyData.drivers[driverName];
        driverFound = true;
        
        weekActivity.tripCount = driverData.tripCount || 0;
        weekActivity.revenue = parseFloat(driverData.totalRevenue || 0);
        weekActivity.company = companyName;
        weekActivity.isActive = weekActivity.tripCount >= 2;

        if (weekActivity.isActive) {
          driverDetails.summary.totalActiveWeeks++;
          driverDetails.summary.totalTrips += weekActivity.tripCount;
          driverDetails.summary.totalRevenue += weekActivity.revenue;

          // Urm캒re탳te cea mai bun캒 탳i cea mai slab캒 s캒pt캒m칙n캒
          if (weekActivity.tripCount > bestWeek.trips) {
            bestWeek = { trips: weekActivity.tripCount, week: week.weekLabel };
          }
          if (weekActivity.tripCount < worstWeek.trips) {
            worstWeek = { trips: weekActivity.tripCount, week: week.weekLabel };
          }
        }
      }
    });

    driverDetails.weeklyActivity.push(weekActivity);
  }

  // Calculeaz캒 mediile
  if (driverDetails.summary.totalActiveWeeks > 0) {
    driverDetails.summary.averageTripsPerWeek = 
      (driverDetails.summary.totalTrips / driverDetails.summary.totalActiveWeeks).toFixed(1);
    driverDetails.summary.bestWeek = bestWeek.week;
    driverDetails.summary.worstWeek = worstWeek.trips !== Infinity ? worstWeek.week : null;
  }

  return driverDetails;
}

/**
 * Ob탵ine sumar anual pentru to탵i 탳oferii
 */
async function getYearlyDriverActivitySummary(year) {
  console.log(`游늳 Getting yearly summary for ${year}`);
  
  const monthlySummaries = [];
  
  for (let month = 1; month <= 12; month++) {
    const monthlyActivity = await analyzeDriverActivityForMonth(year, month);
    monthlySummaries.push({
      month,
      monthName: getMonthName(month),
      totalDrivers: monthlyActivity.totalDrivers,
      totalTrips: monthlyActivity.summary.totalTripsAllDrivers,
      averageTripsPerDriver: monthlyActivity.summary.averageTripsPerDriver,
      mostActiveDriver: monthlyActivity.summary.mostActiveDriver.name
    });
  }

  const yearlyStats = {
    year,
    monthlyBreakdown: monthlySummaries,
    yearlyTotals: {
      totalTripsYear: monthlySummaries.reduce((sum, m) => sum + m.totalTrips, 0),
      averageDriversPerMonth: (monthlySummaries.reduce((sum, m) => sum + m.totalDrivers, 0) / 12).toFixed(1),
      mostProductiveMonth: monthlySummaries.reduce((max, m) => m.totalTrips > max.totalTrips ? m : max, { totalTrips: 0 }),
      leastProductiveMonth: monthlySummaries.reduce((min, m) => m.totalTrips < min.totalTrips ? m : min, { totalTrips: Infinity })
    }
  };

  return yearlyStats;
}

// ==================== HELPER FUNCTIONS ====================

/**
 * Parseaz캒 label-ul s캒pt캒m칙nii pentru a extrage informa탵ii despre dat캒
 */
function parseWeekLabel(weekLabel) {
  // Presupun c캒 weekLabel este 칥n formatul "Week 1 (Jan 1-7, 2024)" sau similar
  const yearMatch = weekLabel.match(/(\d{4})/);
  const weekMatch = weekLabel.match(/Week (\d+)/);
  
  if (!yearMatch || !weekMatch) {
    console.warn(`Could not parse week label: ${weekLabel}`);
    return { year: 0, month: 0, weekNumber: 0 };
  }

  const year = parseInt(yearMatch[1]);
  const weekNumber = parseInt(weekMatch[1]);
  
  // Estimeaz캒 luna bazat캒 pe num캒rul s캒pt캒m칙nii
  const month = Math.ceil(weekNumber / 4.33); // Aproximativ 4.33 s캒pt캒m칙ni per lun캒
  
  return { year, month: Math.min(month, 12), weekNumber };
}

/**
 * Ob탵ine numele lunii
 */
function getMonthName(month) {
  const months = [
    'Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie',
    'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'
  ];
  return months[month - 1] || 'Unknown';
}

/**
 * Calculeaz캒 zilele lucr캒toare dintr-o lun캒 (exclud weekend-urile)
 */
function getWorkingDaysInMonth(year, month) {
  const daysInMonth = new Date(year, month, 0).getDate();
  let workingDays = 0;
  
  for (let day = 1; day <= daysInMonth; day++) {
    const dayOfWeek = new Date(year, month - 1, day).getDay();
    // 0 = Duminic캒, 6 = S칙mb캒t캒
    if (dayOfWeek !== 0 && dayOfWeek !== 6) {
      workingDays++;
    }
  }
  
  return workingDays;
}

// ==================== DATABASE ADDITIONS ====================

// Adaug캒 aceste func탵ii 칥n storage.js pentru persisten탵a datelor

/**
 * Salveaz캒 analiza activit캒탵ii 탳oferilor
 */
async function saveDriverActivityAnalysis(analysisData) {
  try {
    // Po탵i crea o tabel캒 separat캒 pentru a stoca analizele
    const query = `
      INSERT INTO driver_activity_analysis 
      (year, month, analysis_data, created_at) 
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (year, month) 
      DO UPDATE SET 
        analysis_data = $3, 
        updated_at = $4
      RETURNING *
    `;
    
    const result = await db.query(query, [
      analysisData.year,
      analysisData.month,
      JSON.stringify(analysisData),
      new Date()
    ]);
    
    return result.rows[0];
  } catch (error) {
    console.error('Error saving driver activity analysis:', error);
    throw error;
  }
}

/**
 * Ob탵ine analiza salvat캒 pentru o lun캒
 */
async function getDriverActivityAnalysis(year, month) {
  try {
    const query = `
      SELECT * FROM driver_activity_analysis 
      WHERE year = $1 AND month = $2
    `;
    
    const result = await db.query(query, [year, month]);
    
    if (result.rows.length > 0) {
      return JSON.parse(result.rows[0].analysis_data);
    }
    
    return null;
  } catch (error) {
    console.error('Error getting driver activity analysis:', error);
    throw error;
  }
}

// ==================== SQL PENTRU TABEL캑 ====================

/*
CREATE TABLE IF NOT EXISTS driver_activity_analysis (
  id SERIAL PRIMARY KEY,
  year INTEGER NOT NULL,
  month INTEGER NOT NULL,
  analysis_data JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(year, month)
);

CREATE INDEX idx_driver_activity_year_month ON driver_activity_analysis(year, month);
*/